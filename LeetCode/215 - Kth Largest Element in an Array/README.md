# solve1.cc(Sort)

Runtime: 19 ms

Your runtime beats 41.26 % of cpp submissions.

# solve2.cc

Use partition in quick sort which is called quick-select

[2. Selection](https://www.youtube.com/watch?v=CgVYfSyct_M&list=PLRdD1c6QbAqJn0606RlOR6T3yUqFWKwmX&index=31)

Tricky case: if there are duplicate keys

My algorithm here is move same value at array end and move to mid if possible to make the partition pos at the middle of the array.

Runtime: 11 ms

Your runtime beats 84.05 % of cpp submissions.

# solve1.swift(Sort)

Runtime: 44 ms, faster than 78.90% of Swift online submissions for Kth Largest Element in an Array.

Memory Usage: 14.1 MB, less than 88.44% of Swift online submissions for Kth Largest Element in an Array.

# solve2.swift (Priority queue)

Runtime: 140 ms, faster than 8.09% of Swift online submissions for Kth Largest Element in an Array.

Memory Usage: 14.3 MB, less than 58.09% of Swift online submissions for Kth Largest Element in an Array.


# solve1.py

Heap sort

Runtime 1704 ms Beats 27.57%

Memory 27.1 MB Beats 87.52%

# solve2.py

Quick select

Runtime 1894 ms Beats 21.69%

Memory 27.1 MB Beats 64.12%

# solve3.py

Quick select but variant of parition using hi as pivot.

Runtime 1562 ms Beats 30.91%

Memory 27.1 MB Beats 64.12%

# solve4.py

Quick select with 3-way partitioning.

Runtime 2140 ms Beats 18.79%

Memory 27.1 MB Beats 64.12%
